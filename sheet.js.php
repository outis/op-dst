<?php
header('Content-type: text/javascript');

// generated by scripts/req.sh
$requires = [
	'alias' => [ 'dsf', 'field', 'klass', 'range', 'udfs', ],
	'funcs' => [ ],
	'klass' => [ ],
	'udfs' => [ 'dsf', 'klass', 'pips', 'reorder', ],
	'dsf' => [ 'field', 'klass', 'pips', ],
	'range' => [ ],
	'field' => [ 'dsf', ],
	'tabs' => [ ],
	'reorder' => [ 'udfs', ],
	'pips' => [ 'dsf', 'field'],
];

$required = ['module'=>1, 'funcs'=>1];

// convert to a structure more readily used by `add_requirements`
foreach ($requires as $k => &$v) {
	$v = array_combine($v, $v);
}

// transitive closure for $requires
foreach ($requires as $module => &$reqs) {
	do {
		$nReqs = count($reqs);
		// potentially could be made more performant by using array_diff_key
		foreach ($reqs as $req => $_) {
			$reqs += $requires[$req];
		}
	} while ($nReqs < count($reqs));
}

// check user input for a list of modules to include
function get_modules() {
	$scripts = [];
	$modules = [];
	if (isset($_REQUEST['inc'])) {
		if (is_array($_REQUEST['inc'])) {
			return $_REQUEST['inc'];
		}
		$modules = $_REQUEST['inc'];
	} else {
		/* Scan input keys for a CSV of modules. If there isn't a CSV, check keys
		   w/ empty values to see if they're modules. */
		foreach ($_REQUEST as $key => $val) {
			$key = trim($key, " \t,");
			if ('' === $val) {
				if (strpos($key, ',', 1)) {
					$modules = $key;
					break;
				}
				if (file_exists("scripts/${key}.js")) {
					$scripts[] = $key;
				}
			}
		}
	}
	if (! $modules) {
		if ($scripts) {
			$modules = $scripts;
		} elseif (! $modules) {
			echo "// Couldn't determine which scripts to load, as none were specified, so loading all.\n";
			$modules = array_map(
				fn ($pathname) => preg_replace('%.*/|\.js$%', '', $pathname),
				glob('scripts/*.js')
			);
		}
		return $modules;
	}
	return preg_split('/\s*,\s*/', $modules);
}

/**
 * Extend the list of modules by adding any additional modules they require.
 *
 * TODO: recurse (or precalculate transitive closure of $requires).
 */
function add_requirements(&$modules) {
	global $requires, $required;

	$incs = array_combine($modules, $modules);
	// dsf & pips are always required
	$incs += ['dsf'=>'dsf', 'pips'=>'pips'];
	foreach ($incs as $module => $_) {
		if (isset($requires[$module])) {
			$incs += $requires[$module];
		}
	}
	// 
	$incs = array_diff_key($incs, $required);
	return $incs;
}

function include_modules($modules) {
	$modules = add_requirements($modules);
	$included = [];
	echo "\n\tconst modules = ", json_encode($modules), ";\n\n";
	foreach ($modules as $module) {
		if (file_exists($file = "scripts/${module}.js")) {
			readfile($file);
			$included[$module] = $module;
		}
	}
	//echo "\n\tconst included = ", json_encode($included), ";\n\n";
	return $included;
}
?>
/**
 * TODO: 
 * + UDF reorder button for mobile (click & swap)
 */
(function ($) {
	var $slug = $('.dst_slug'),
		slug = $slug.text(),
		globals = {},
		editMarker = 'Click to edit',
		containerId,
		pippedKinds = ['attributes', 'abilities', 'advantages', 'arcanoi'];

	const aliases = globals.aliases = {
		simple: {
			// attributes
			'presence': 'charisma',
			'composure': 'appearance',

			// resources
			'experiance': 'experience',
			// jp12x_splat
			'willpower': 'perm_willpower',
			'current_will': 'curr_willpower',
			'health': 'perm_health',
			'chealth': 'curr_health',

			// old_wod_generic
			'humanity_value': 'health',
		},
		
		templates: {
			// old_wod_generic
			'bg{i}': 'bg_{i}_name',
			'bg{i}_value': 'bg_{i}_value',
			'bg{i}_expanded{j}': 'bg_{i}_descr',
			
			// cWoD-Revised
		}
	};

	
	<?php
	foreach ($required as $module => $_) {
		readfile("scripts/${module}.js");
	}
	
	$modules = get_modules();
	$included = include_modules($modules);
	?>
	for (let name of modules) {
		module.register(name, globals[name]);
	}

	/*** */
	function edit() {
		pips.start();
		udfs.start();
	}

	function noedit() {
		pips.stop();
		udfs.stop();
	}

	$.extend(globals, {edit, noedit});

	module.all('init');
	
	/*** DS API */
	let listeners = {};

	let $context;
	listeners.PreLoad = function dataPreLoad(opts) {
		let sel = `#${opts.containerId}`;
		$context = $(sel);
		$context.selector = sel;
		$context.containerId = opts.containerId;
		module.all('preLoad', opts, $context);
	};

	//module.registerDependency('pips', 'postLoad', ['dsf']);
	listeners.PostLoad = function dataPostLoad(opts) {
		module.all('postLoad', opts, $context);
		
		dsf.init(opts);
		pips.init(); // can't happen before .dsf are pipped
		reorder.init();

		if (opts.isEditable) {
			edit();
		} else {
			noedit();
			// For shadow sheet.
			let psyche_slug = $context.find('.dsf_psyche_slug').text();
			if (psyche_slug) {
				$context.find('.dsf_psyche').wrap(`<a href="/characters/${psyche_slug}"></a>`);
			}
		}
	};

	listeners.Change = function dataChange({containerId, fieldName, fieldValue}) {
		let dsfName = dsf.addPrefix(fieldName);

		module.all('change', opts, $context);
		
		if (dsf.linked.isExtra(fieldName)) {
			let base = dsf.addPrefix(dsf.linked.base(fieldName)),
				$base = $(`.${base}`);
			if (pips.is($base, fieldName, fieldValue)) {
				pips.reassemble($base);
			} else {
			}
		}
	};

	listeners.PreSave = function dataPreSave({containerId, slug, isEditable}) {
		/* convert back to numeric fields */
		dsf.each(function (elt, $elt, name, value) {
			if (pips.is(elt, name, value)) {
				pips.unpippify($elt, {name, value});
			}
		});

		module.all('preSave', opts, $context);
	};

	/* ${slug}_dataPreLoad, at least, must be present before the dynamic sheet framework loads DSFs, so might as well do them all. */
	function registerListeners() {
		for (let evt in listeners) {
			window[`${slug}_data${evt}`] = listeners[evt];
		}
	}
	
	if (slug) {
		registerListeners();
	} else {
		$(function () {
			if (! slug) {
				$slug = $('.dst_slug');
				slug = $slug.text();
				registerListeners();
			}
		});
	}
	
	// for debugging
	window.mll_sheet = $.extend(window.mll_sheet || {}, globals);

})(jQuery);
